---
alwaysApply: true
---
# Cursor IDE Rules
# Pokemon Technical Challenge

## Project Context

You are helping build a Pokemon browser application for a technical interview at Ballast Lane. The application has a Next.js frontend (SSR-first) and Node.js/Express backend. Focus on clean architecture, testing, and code quality.

## Evaluation Criteria (What the reviewers care about)

1. **Clean Architecture** - Separation of concerns, component independence
2. **Testing** - Sufficient coverage, TDD preferred
3. **Code Quality** - Organized, readable, best practices
4. **Functionality** - Works without bugs, NO console warnings
5. **GenAI Usage** - Document prompts and modifications

## Technical Decisions (Already Made)

### Frontend Stack
- **Next.js 16 with App Router** (latest, supports React 19)
- **React 19** with React Compiler enabled
- TypeScript (strict mode)
- **SSR-first architecture** with hybrid client-side interactions
- **Cookies for auth token** (frontend-managed via js-cookie)
- **Next.js Middleware** for route protection
- **Zustand for UI state only** (search input, sort selection, UI toggles)
- **TanStack Query v5** for client-side data fetching (pagination, search, mutations)
- **React 19 `use` hook** for consuming promises in Server Components
- Tailwind CSS for styling
- Vitest + React Testing Library for tests

### Backend Stack
- Node.js + Express
- TypeScript
- JWT for auth (jsonwebtoken)
- Cookie-based token delivery (frontend stores in cookie)
- In-memory cache (Map with TTL)
- Vitest for tests

### Architecture Patterns
- Feature-based folder structure
- Server Components for initial data fetching (SSR + SEO)
- Client Components for interactivity
- Services layer for business logic
- Repository pattern for external APIs
- Centralized config for env vars

## SSR Architecture

### Data Fetching Strategy

| Page/Action | Where | Method | Why |
|-------------|-------|--------|-----|
| Initial Pokemon list | Server Component | `fetch` + `use` hook | SEO, fast initial load |
| Pokemon detail page | Server Component | `fetch` + `use` hook | SEO for each Pokemon |
| Pagination (next/prev) | Client Component | React Query | Fast navigation, no full reload |
| Search/Filter | Client Component | React Query or local | Instant feedback |
| Login | Client Component | React Query mutation | User interaction |
| Logout | Client Component | React Query + clear cookie | User interaction |

### Server vs Client Components

```
app/
├── layout.tsx              # Server (providers are client)
├── page.tsx                # Server (redirect logic)
├── login/
│   └── page.tsx            # Client ('use client' - form interaction)
├── pokemon/
│   ├── page.tsx            # Server (prefetch list)
│   ├── PokemonPageClient.tsx  # Client (search, sort, pagination)
│   └── [id]/
│       └── page.tsx        # Server (prefetch detail)
│       └── PokemonDetailClient.tsx  # Client (if any interactivity)
```

### Middleware for Auth

```typescript
// middleware.ts - runs on edge, checks cookie
export function middleware(request: NextRequest) {
  const token = request.cookies.get('auth-token')
  const isAuthPage = request.nextUrl.pathname === '/login'
  const isProtectedRoute = request.nextUrl.pathname.startsWith('/pokemon')

  if (isProtectedRoute && !token) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  if (isAuthPage && token) {
    return NextResponse.redirect(new URL('/pokemon', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: ['/login', '/pokemon/:path*']
}
```

### Cookie Management

```typescript
// Use js-cookie for frontend cookie management
import Cookies from 'js-cookie'

// On login success
Cookies.set('auth-token', token, {
  expires: 1, // 1 day
  sameSite: 'strict',
  secure: process.env.NODE_ENV === 'production'
})

// On logout
Cookies.remove('auth-token')

// Reading token for API calls
const token = Cookies.get('auth-token')
```

### Server Component Data Fetching

```typescript
// app/pokemon/page.tsx (Server Component)
import { cookies } from 'next/headers'
import { PokemonPageClient } from './PokemonPageClient'

async function getPokemons() {
  const cookieStore = await cookies()
  const token = cookieStore.get('auth-token')?.value

  const res = await fetch(`${process.env.API_URL}/pokemons?limit=20`, {
    headers: { Authorization: `Bearer ${token}` },
    cache: 'no-store' // or use revalidate for caching
  })

  if (!res.ok) throw new Error('Failed to fetch')
  return res.json()
}

export default async function PokemonPage() {
  const initialData = await getPokemons()

  return <PokemonPageClient initialData={initialData} />
}
```

### Client Component with React Query Hydration

```typescript
// app/pokemon/PokemonPageClient.tsx
'use client'

import { useQuery } from '@tanstack/react-query'

export function PokemonPageClient({ initialData }) {
  const [page, setPage] = useState(0)

  const { data } = useQuery({
    queryKey: ['pokemons', page],
    queryFn: () => fetchPokemons({ offset: page * 20 }),
    initialData: page === 0 ? initialData : undefined,
  })

  // ... rest of component
}
```

## Coding Standards

### TypeScript
- NO `any` types - use `unknown` and narrow
- Define explicit return types for functions
- Use interfaces for object shapes
- Use type for unions/intersections

### React 19 / Next.js 15
- **Server Components by default** - only add 'use client' when needed
- Use React 19's `use` hook for consuming promises in Server Components
- Use `async/await` in Server Components for data fetching
- Keep Client Components small and focused on interactivity
- Use Next.js Middleware for auth protection (not client-side redirects)

### When to use 'use client'
- Forms and user input
- useState, useEffect, useRef
- Event handlers (onClick, onChange, etc.)
- Browser-only APIs
- React Query hooks
- Zustand stores

### State Management
- **Cookies** for auth token (js-cookie library)
- **Zustand** for UI state only (search input, sort, toggles)
- **React Query** for client-side server state (pagination, mutations)
- **Server Components** for initial data (SSR)

### Error Handling
- Use try/catch in async functions
- Use error.tsx for route error boundaries
- Display user-friendly error messages
- Log errors for debugging
- Always handle loading and error states in UI

### Testing
- Write tests alongside code (not after)
- Test behavior, not implementation
- Use descriptive test names
- Mock external dependencies
- Test both Server and Client Components appropriately

## File Naming Conventions

```
components/    PascalCase.tsx     (LoginForm.tsx)
hooks/         camelCase.ts       (useAuth.ts)
services/      camelCase.ts       (authApi.ts)
stores/        camelCase.ts       (authStore.ts)
types/         camelCase.ts       (auth.types.ts)
utils/         camelCase.ts       (formatters.ts)
tests/         *.test.ts(x)       (LoginForm.test.tsx)
```

## Import Order

```typescript
// 1. React/Next
import { useState } from 'react'
import { useRouter } from 'next/navigation'

// 2. External libraries
import { useQuery } from '@tanstack/react-query'
import { create } from 'zustand'

// 3. Internal absolute imports
import { Button } from '@/shared/components/Button'
import { useAuth } from '@/features/auth/hooks/useAuth'

// 4. Relative imports
import { LoginFormProps } from './LoginForm.types'
import styles from './LoginForm.module.css'
```

## Component Structure Templates

### Server Component (default)

```tsx
// app/pokemon/page.tsx
import { cookies } from 'next/headers'
import { PokemonPageClient } from './PokemonPageClient'

async function getData() {
  const cookieStore = await cookies()
  const token = cookieStore.get('auth-token')?.value

  const res = await fetch(`${process.env.API_URL}/pokemons`, {
    headers: { Authorization: `Bearer ${token}` },
  })

  if (!res.ok) throw new Error('Failed to fetch')
  return res.json()
}

export default async function PokemonPage() {
  const data = await getData()
  return <PokemonPageClient initialData={data} />
}
```

### Client Component

```tsx
'use client'

import { useState } from 'react'
import { useQuery } from '@tanstack/react-query'
// ... other imports

// Types
interface ComponentProps {
  initialData: PokemonListResponse
}

// Component
export function PokemonPageClient({ initialData }: ComponentProps) {
  // UI State (Zustand or local)
  const [searchTerm, setSearchTerm] = useState('')
  const [page, setPage] = useState(0)

  // Server State (React Query)
  const { data, isLoading } = useQuery({
    queryKey: ['pokemons', page],
    queryFn: () => fetchPokemons({ offset: page * 20 }),
    initialData: page === 0 ? initialData : undefined,
  })

  // Event handlers
  const handleSearch = (term: string) => {}

  // Early returns
  if (isLoading) return <Loading />

  // Main render
  return (
    <div>
      {/* JSX */}
    </div>
  )
}
```

### Zustand Store (UI State Only)

```typescript
// stores/uiStore.ts
import { create } from 'zustand'

interface UIState {
  searchTerm: string
  sortBy: 'name' | 'number'
  sortOrder: 'asc' | 'desc'
  setSearchTerm: (term: string) => void
  setSorting: (by: 'name' | 'number', order: 'asc' | 'desc') => void
}

export const useUIStore = create<UIState>((set) => ({
  searchTerm: '',
  sortBy: 'number',
  sortOrder: 'asc',
  setSearchTerm: (term) => set({ searchTerm: term }),
  setSorting: (by, order) => set({ sortBy: by, sortOrder: order }),
}))
```

## API Patterns

### Server-Side Fetch (Server Components)
```typescript
// For Server Components - use native fetch with cookies
import { cookies } from 'next/headers'

async function fetchFromAPI(endpoint: string) {
  const cookieStore = await cookies()
  const token = cookieStore.get('auth-token')?.value

  const res = await fetch(`${process.env.API_URL}${endpoint}`, {
    headers: {
      'Content-Type': 'application/json',
      ...(token && { Authorization: `Bearer ${token}` }),
    },
  })

  if (!res.ok) {
    throw new Error(`API Error: ${res.status}`)
  }

  return res.json()
}
```

### Client-Side API Client
```typescript
// shared/lib/apiClient.ts
import Cookies from 'js-cookie'

const API_URL = process.env.NEXT_PUBLIC_API_URL

export async function apiClient<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const token = Cookies.get('auth-token')

  const res = await fetch(`${API_URL}${endpoint}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...(token && { Authorization: `Bearer ${token}` }),
      ...options.headers,
    },
  })

  if (res.status === 401) {
    Cookies.remove('auth-token')
    window.location.href = '/login'
    throw new Error('Unauthorized')
  }

  if (!res.ok) {
    throw new Error(`API Error: ${res.status}`)
  }

  return res.json()
}
```

### Auth Service (Client-Side)
```typescript
// features/auth/services/authApi.ts
import Cookies from 'js-cookie'
import { apiClient } from '@/shared/lib/apiClient'

export async function login(credentials: LoginCredentials) {
  const response = await apiClient<LoginResponse>('/auth/login', {
    method: 'POST',
    body: JSON.stringify(credentials),
  })

  // Store token in cookie
  Cookies.set('auth-token', response.token, {
    expires: 1, // 1 day
    sameSite: 'strict',
    secure: process.env.NODE_ENV === 'production',
  })

  return response
}

export function logout() {
  Cookies.remove('auth-token')
}

export function isAuthenticated(): boolean {
  return !!Cookies.get('auth-token')
}
```

### React Query Hooks
```typescript
// features/pokemon/hooks/usePokemonList.ts
import { useQuery } from '@tanstack/react-query'
import { apiClient } from '@/shared/lib/apiClient'

export function usePokemonList(params: { offset: number; limit: number }, initialData?: PokemonListResponse) {
  return useQuery({
    queryKey: ['pokemons', params],
    queryFn: () => apiClient<PokemonListResponse>(`/pokemons?offset=${params.offset}&limit=${params.limit}`),
    initialData: params.offset === 0 ? initialData : undefined,
  })
}
```

## Common Gotchas to Avoid

1. **Don't use 'use client' unnecessarily** - Server Components are the default
2. **Don't use hooks in Server Components** - useState, useEffect, etc. require 'use client'
3. **Don't forget to await cookies()** - Next.js 15 requires awaiting cookies()
4. **Don't leave console.logs** - they count against you
5. **Don't hardcode URLs** - use environment variables
6. **Don't forget CORS** - backend needs cors middleware
7. **Don't import Client Components into Server Components directly for data** - pass data as props
8. **Don't use localStorage for auth** - use cookies for SSR compatibility
9. **Don't forget the middleware.ts** - it handles auth protection
10. **Don't mix server-only and client-only code** - keep clear boundaries

## Quick Reference: Next.js 15 Middleware

```typescript
// middleware.ts (root level)
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const token = request.cookies.get('auth-token')?.value
  const { pathname } = request.nextUrl

  // Protect /pokemon routes
  if (pathname.startsWith('/pokemon') && !token) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // Redirect authenticated users away from login
  if (pathname === '/login' && token) {
    return NextResponse.redirect(new URL('/pokemon', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: ['/login', '/pokemon/:path*'],
}
```

## Quick Reference: TanStack Query with SSR

```typescript
// For initial data from Server Component
const { data } = useQuery({
  queryKey: ['pokemons', { offset, limit }],
  queryFn: () => fetchPokemons({ offset, limit }),
  initialData: offset === 0 ? initialData : undefined, // From server
  staleTime: 60 * 1000, // Consider fresh for 1 minute
})

// For mutations (login, etc.)
const loginMutation = useMutation({
  mutationFn: login,
  onSuccess: () => {
    router.push('/pokemon')
  },
})
```

## Quick Reference: Zustand (UI State Only)

```typescript
// No persistence needed - UI state resets on page load
import { create } from 'zustand'

interface UIState {
  searchTerm: string
  sortBy: 'name' | 'number'
  sortOrder: 'asc' | 'desc'
  setSearchTerm: (term: string) => void
  setSorting: (by: 'name' | 'number', order: 'asc' | 'desc') => void
  reset: () => void
}

export const useUIStore = create<UIState>((set) => ({
  searchTerm: '',
  sortBy: 'number',
  sortOrder: 'asc',
  setSearchTerm: (searchTerm) => set({ searchTerm }),
  setSorting: (sortBy, sortOrder) => set({ sortBy, sortOrder }),
  reset: () => set({ searchTerm: '', sortBy: 'number', sortOrder: 'asc' }),
}))
```

## When Generating Code

1. Always include TypeScript types
2. Always handle loading and error states
3. Always add aria labels for accessibility
4. Always consider mobile-first responsive design
5. Always write at least one test for the component/function
6. Never use inline styles - use Tailwind classes
7. Never ignore TypeScript errors - fix them properly
8. When creating new files make sure there is only one line break at the end

## Project File References

- See docs/PRODUCT_REQUIREMENTS_DOCUMENT.md for product requirements.
- See docs/USER_STORIES.md for detailed user stories.
- See docs/TEST_CASES.md for comprehensive test cases.

When I ask you to implement a feature, check these files first for context.
